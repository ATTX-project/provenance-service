# import random
from rdflib import Graph, BNode, Literal
# , BNode, URIRef, Literal
from rdflib.namespace import RDF, DCTERMS, XSD
from prov.utils.prefixes import bind_prefix, create_URI, ATTXProv, PROV, ATTXBase
# ATTXBase, ATTXOnto, PROV, PWO, SD
from prov.utils.logs import app_logger
from prov.utils.graph_store import GraphStore


def construct_provenance(provObject, payload=None):
    """Parse Provenance Object and construct Provenance Graph."""
    graph = Graph()
    bind_prefix(graph)
    activityID = ''.join(filter(None, ('activity',
                                provObject['context']['activityID'])))
    workflowID = ''.join(filter(None, ('workflow',
                                provObject['context']['workflowID'])))
    stepID = ''.join(filter(None, ('step',
                            provObject['context']['stepID'])))
    agentID = ''.join(filter(None, ('agent',
                                    provObject['agent']['ID'])))
    base_id = "_".join(filter(None, (workflowID, activityID, stepID, agentID)))
    app_logger.info('Constructed base ID: {0}'.format(base_id))
    try:
        store_provenance(prov_activity(graph, base_id, provObject))
    except Exception as error:
        app_logger.error('Something is wrong with parsing the provObject: {0}'.format(error))


def store_provenance(graph):
    """Store resulting provenance in the Graph Store."""
    storage = GraphStore()
    storage_request = storage.graph_update(ATTXProv, graph)
    return storage_request


def prov_activity(graph, base_id, provObject):
    """Construct Activity provenance Graph."""
    activity = provObject['activity']
    agent = provObject['agent']
    graph.add((base_id, RDF.type, PROV.Activity))
    # graph.add((URIRef("{0}activity{1}".format(ATTXBase, activity_id)), RDF.type, ATTXOnto.WorkflowExecution))
    graph.add((base_id, DCTERMS.title, activity['title']))
    graph.add((base_id, PROV.startedAtTime, Literal(activity['startTime'], datatype=XSD.dateTime)))
    graph.add((base_id, PROV.endedAtTime, Literal(activity['endTime'], datatype=XSD.dateTime)))
    graph.add((base_id, PROV.wasAssociatedWith, create_URI(ATTXBase, agent['ID'])))
    # information about the agent and the artifact used.
    graph.add((create_URI(ATTXBase, agent), ATTXOnto.usesArtifact, create_URI(ATTXBase, artifact)))
    if usedDatasetList is not None:
        for dataset in usedDatasetList:
            dataset_provenance(graph, dataset, activity_id, "used")
    dataset_provenance(graph, str(generatedDataset), activity_id, "generated")
    app_logger.info('Construct activity metadata for Activity: activity{0}.' .format(activity_id))
    return graph

def prov_association(graph, base_id, provObject):
    """Associate an activity with an Agent."""
    bnode = BNode()
    graph.add((base_id, PROV.qualifiedAssociation, bnode))
    graph.add((bnode, RDF.type, PROV.Assocation))
    graph.add((bnode, PROV.hadPlan, URIRef("{0}workflow{1}".format(ATTXBase, workflow_id))))
    graph.add((bnode, PROV.agent, create_URI(ATTXBase, agent)))
    graph.add((create_URI(ATTXBase, agent), RDF.type, PROV.Agent))
    return graph


# def construct_provenance(provObject):
#     """Construct provenance graph based on request."""
#     graph = Graph()
#     bind_prefix(graph)
#     try:
#         workflow_provenance(graph, strategy)
#         activity_provenance(graph, startTime, endTime, strategy, generatedDataset, usedDatasetList)
#         store_api = "http://{0}:{1}/{2}/data?graph={3}".format(endpoint['host'], endpoint['port'], endpoint['dataset'], ATTXProv)
#         headers = {'Content-Type': 'text/turtle'}
#         result = requests.post(store_api, data=graph.serialize(format='turtle'), headers=headers)
#         app_logger.info('Add to graph store: "{0}" the result of the linking strategy.'.format(ATTXProv))
#         return result.status_code
#     except Exception as error:
#         app_logger.error('Something is wrong: {0}'.format(error))
#         raise falcon.HTTPUnprocessableEntity(
#             'Unprocessable Graph generated by strategy',
#             'Could not update graph store with the graph generated by the strategy.'
#         )


# def activity_provenance(graph, startTime, endTime, strategy, generatedDataset, usedDatasetList=None):
#     """Generate activity related provenance."""
#     bnode = BNode()
#     activity_id = str(random.randint(1e15, 1e16))
#     workflow_id = "_link_{0}".format(strategy)
#
#     graph.add((URIRef("{0}activity{1}".format(ATTXBase, activity_id)), RDF.type, PROV.Activity))
#     graph.add((URIRef("{0}activity{1}".format(ATTXBase, activity_id)), RDF.type, ATTXOnto.WorkflowExecution))
#     graph.add((URIRef("{0}activity{1}".format(ATTXBase, activity_id)), PROV.startedAtTime, Literal(startTime, datatype=XSD.dateTime)))
#     graph.add((URIRef("{0}activity{1}".format(ATTXBase, activity_id)), PROV.endedAtTime, Literal(endTime, datatype=XSD.dateTime)))
#     graph.add((URIRef("{0}activity{1}".format(ATTXBase, activity_id)), PROV.qualifiedAssociation, bnode))
#     graph.add((bnode, RDF.type, PROV.Assocation))
#     graph.add((bnode, PROV.hadPlan, URIRef("{0}workflow{1}".format(ATTXBase, workflow_id))))
#     graph.add((bnode, PROV.agent, URIRef("{0}{1}".format(ATTXBase, agent))))
#     graph.add((URIRef("{0}{1}".format(ATTXBase, agent)), RDF.type, PROV.Agent))
#     # information about the agent and the artifact used.
#     graph.add((URIRef("{0}{1}".format(ATTXBase, agent)), ATTXOnto.usesArtifact, URIRef("{0}{1}".format(ATTXBase, artifact))))
#     if usedDatasetList is not None:
#         for dataset in usedDatasetList:
#             dataset_provenance(graph, dataset, activity_id, "used")
#     dataset_provenance(graph, str(generatedDataset), activity_id, "generated")
#     app_logger.info('Construct activity metadata for Activity: activity{0}.' .format(activity_id))
#     return graph
#
#
# def dataset_provenance(graph, dataset, activityID, datasetType):
#     """Generate datasets associated to the provenance."""
#     graph.add((URIRef(dataset), RDF.type, ATTXOnto.Dataset))
#     graph.add((URIRef(dataset), RDF.type, SD.Dataset))
#     if datasetType == "used":
#         graph.add((URIRef("{0}activity{1}".format(ATTXBase, activityID)), PROV.used, URIRef(dataset)))
#     elif datasetType == "generated":
#         graph.add((URIRef("{0}activity{1}".format(ATTXBase, activityID)), PROV.generated, URIRef(dataset)))
#         graph.add((URIRef(dataset), DC.title, Literal("activity{0} Linking Dataset".format(activityID))))
#         graph.add((URIRef(dataset), DC.description, Literal("Dataset generated from activity".format(activityID))))
#         graph.add((URIRef(dataset), DC.publisher, Literal("ATTX HULib")))
#         # graph.add((URIRef(dataset), DC.source, Literal()))
#         # graph.add((URIRef(dataset), CC.license, ATTXOnto.CC0))
#     return graph
#
#
# def workflow_provenance(graph, strategy):
#     """Generate workflow related provenance."""
#     workflow_id = "_link_{0}".format(strategy)
#     # There will be only one type of workflow and steps. Steps might differ in configuration.
#     graph.add((URIRef("{0}workflow{1}".format(ATTXBase, workflow_id)), RDF.type, ATTXOnto.Workflow))
#     graph.add((URIRef("{0}workflow{1}".format(ATTXBase, workflow_id)), DC.title, Literal("Linking Workflow")))
#     graph.add((URIRef("{0}workflow{1}".format(ATTXBase, workflow_id)), DC.description, Literal("Workflow specific to the link GM API endpoint")))
#     # Add predifined steps for the workflow
#     generate_step(graph, 1, strategy, "Retrieve {0} parameters".format(strategy),
# "Retrieve paramters for the linking for the specified strategy.", workflow_id)
#     generate_step(graph, 2, strategy, "Construct linking graph for {0}".format(strategy), "Generate linking graph based on strategy parameters.", workflow_id)
#     generate_step(graph, 3, strategy, "Add to graph store", "Add generated linking graph by {0} to the graph store.".format(strategy), workflow_id)
#     graph.add((URIRef("{0}step{1}_{2}".format(ATTXBase, 1, strategy)), PWO.hasNextStep, URIRef("{0}step{1}_{2}".format(ATTXBase, 2, strategy))))
#     graph.add((URIRef("{0}step{1}_{2}".format(ATTXBase, 2, strategy)), PWO.hasNextStep, URIRef("{0}step{1}_{2}".format(ATTXBase, 3, strategy))))
#
#     app_logger.info('Construct activity metadata for Workflow: workflow{0} + associated steps.' .format(workflow_id))
#     return graph
#
#
# def generate_step(graph, stepID, strategy, title, description, workflow):
#     """Generate step details."""
#     graph.add((URIRef("{0}step{1}_{2}".format(ATTXBase, stepID, strategy)), RDF.type, ATTXOnto.Step))
#     graph.add((URIRef("{0}step{1}_{2}".format(ATTXBase, stepID, strategy)), DC.title, Literal(title)))
#     graph.add((URIRef("{0}step{1}_{2}".format(ATTXBase, stepID, strategy)), DC.description, Literal(description)))
#     graph.add((URIRef("{0}workflow{1}".format(ATTXBase, workflow)), PWO.hasStep, URIRef("{0}step{1}_{2}".format(ATTXBase, stepID, strategy))))
#     return graph
